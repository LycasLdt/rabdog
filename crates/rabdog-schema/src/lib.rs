//! The code is generated by DeepSeek R1.
extern crate proc_macro;

use heck::ToPascalCase;
use proc_macro::TokenStream;
use quote::quote;
use std::collections::HashMap;
use syn::parse::{Parse, ParseStream, Result};
use syn::token::Bracket;
use syn::{Ident, Path, Token, Type, TypePath, bracketed, parse_macro_input};

/// 宏输入的结构
struct SchemaInput {
    struct_name: Ident,
    fields: Vec<FieldSpec>,
}

struct FieldSpec {
    path: Vec<PathSegment>,
    ty: Type,
}

impl Parse for SchemaInput {
    fn parse(input: ParseStream) -> Result<Self> {
        let struct_name = input.parse()?;
        input.parse::<Token![;]>()?;
        let fields = input.parse_terminated(FieldSpec::parse, Token![,])?;
        Ok(SchemaInput {
            struct_name,
            fields: fields.into_iter().collect(),
        })
    }
}

impl Parse for FieldSpec {
    fn parse(input: ParseStream) -> Result<Self> {
        let mut path = Vec::new();
        while !input.peek(Token![:]) {
            let ident = input.parse::<PathSegment>()?;
            path.push(ident);
            if input.peek(Token![.]) {
                input.parse::<Token![.]>()?;
            } else {
                break;
            }
        }
        input.parse::<Token![:]>()?;
        let ty = input.parse()?;
        Ok(FieldSpec { path, ty })
    }
}

/// 树结构节点，用于构建嵌套结构
struct Node {
    struct_name: Ident,
    fields: Vec<Field>,
    children: HashMap<Ident, Node>,
}

struct Field {
    name: Ident,
    ty: Type,
}

struct PathSegment {
    ident: Ident,
    is_array: bool,
}

impl Parse for PathSegment {
    fn parse(input: ParseStream) -> Result<Self> {
        let ident = input.parse::<Ident>()?;
        let is_array = if input.peek(Bracket) {
            let _content;
            bracketed!(_content in input);

            true
        } else {
            false
        };
        Ok(PathSegment { ident, is_array })
    }
}

fn build_tree(struct_name: Ident, fields: &[FieldSpec]) -> Node {
    let mut root = Node {
        struct_name: struct_name.clone(),
        fields: Vec::new(),
        children: HashMap::new(),
    };

    for field in fields {
        let mut current = &mut root;
        for (i, segment) in field.path.iter().enumerate() {
            let is_last = i == field.path.len() - 1;

            // 处理最后一个段的类型
            if is_last {
                current.fields.push(Field {
                    name: segment.ident.clone(),
                    ty: field.ty.clone(),
                });

                break;
            }

            let child_struct_name = format!(
                "_{}{}",
                struct_name,
                segment.ident.to_string().to_pascal_case()
            );
            let child_ident = Ident::new(&child_struct_name, segment.ident.span());

            // 处理数组段
            if segment.is_array {
                // 创建或获取子节点
                let entry = current
                    .children
                    .entry(segment.ident.clone())
                    .or_insert(Node {
                        struct_name: child_ident.clone(),
                        fields: Vec::new(),
                        children: HashMap::new(),
                    });

                // 添加当前字段为 Vec<子结构体>
                if !current.fields.iter().any(|f| f.name == segment.ident) {
                    let vec_ty = Type::Verbatim(quote! { Vec<#child_ident> });
                    current.fields.push(Field {
                        name: segment.ident.clone(),
                        ty: vec_ty,
                    });
                }

                current = entry;
            } else {
                // 处理普通段
                let entry = current
                    .children
                    .entry(segment.ident.clone())
                    .or_insert(Node {
                        struct_name: child_ident.clone(),
                        fields: Vec::new(),
                        children: HashMap::new(),
                    });

                if !current.fields.iter().any(|f| f.name == segment.ident) {
                    current.fields.push(Field {
                        name: segment.ident.clone(),
                        ty: Type::Path(TypePath {
                            qself: None,
                            path: Path::from(child_ident.clone()),
                        }),
                    });
                }

                current = entry;
            }
        }
    }
    root
}

fn generate_structs(node: &Node) -> proc_macro2::TokenStream {
    let mut tokens = proc_macro2::TokenStream::new();
    // 递归生成子结构体
    for child in node.children.values() {
        tokens.extend(generate_structs(child));
    }
    // 生成当前结构体
    let struct_name = &node.struct_name;
    let fields = node.fields.iter().map(|field| {
        let name = &field.name;
        let ty = &field.ty;
        quote! { pub #name: #ty }
    });
    tokens.extend(quote! {
        #[derive(Debug, serde::Deserialize)]
        #[serde(rename_all = "camelCase")]
        pub struct #struct_name {
            #(#fields),*
        }
    });
    tokens
}

#[proc_macro]
pub fn schema(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as SchemaInput);
    let root = build_tree(input.struct_name, &input.fields);
    let tokens = generate_structs(&root);
    tokens.into()
}
